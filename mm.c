/*
 * mm-naive.c - The fastest, least memory-efficient malloc package.
 * 
 * In this naive approach, a block is allocated by simply incrementing
 * the brk pointer.  A block is pure payload. There are no headers or
 * footers.  Blocks are never coalesced or reused. Realloc is
 * implemented directly using mm_malloc and mm_free.
 *
 * NOTE TO STUDENTS: Replace this header comment with your own header
 * comment that gives a high level description of your solution.
 */

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <unistd.h>
#include <string.h>

#include "mm.h"
#include "memlib.h"

/*********************************************************
 * NOTE TO STUDENTS: Before you do anything else, please
 * provide your team information in the following struct.
 ********************************************************/
team_t team = {
    /* Team name */
    "team_1",
    /* First member's full name */
    "ê¶Œë„í¬",
    /* First member's email address */
    "shiwy15@gmail.com",
    /* Second member's full name (leave blank if none) */
    "",
    /* Second member's email address (leave blank if none) */
    ""
};

/********************************************************/
/* ğŸš¨ ê¸°ë³¸ ìƒìˆ˜ ë° ë§¤í¬ë¡œ ì •ì˜(ì¶”ê°€) : CSAPP ê·¸ë¦¼ 9.43 ì°¸ê³  ğŸš¨ */ 

#define WSIZE 4  // ì›Œë“œì™€ header, footerì˜ í¬ê¸°(byte)
#define DSIZE 8  // double ì›Œë“œì˜ í¬ê¸°(byte)
#define CHUNKSIZE (1<<12)  // í™•ì¥ heapì— ì‚¬ìš©í•  ê¸°ë³¸ í¬ê¸°(byte) : 2^12

#define MAX(x,y) ((x) > (y) ? (x) : (y))  // xì™€ y ì¤‘ í° ê°’ì„ ë°˜í™˜í•˜ëŠ” ë§¤í¬ë¡œ
#define PACK(size, alloc) ((size)|(alloc))  // ë¸”ë¡ì˜ í¬ê¸°ì™€ í• ë‹¹ ë¹„íŠ¸ë¥¼ í•©ì¹œ ê°’ì„ ë°˜í™˜í•˜ëŠ” ë§¤í¬ë¡œ
// bit or ì—°ì‚°ìë¥¼ í†µí•´ í•˜ë‚˜ì˜ wordë¡œ í•©ì¹¨.
// ì˜ˆ) pack(16,1)ì€ 16ì˜ ì´ì§„ìˆ˜ê°’(10000) ëì— 1ì„í•©ì³ (10001)ì„ ë°˜í™˜. ìµœì¢…ì ìœ¼ë¡œëŠ” 0001 0001 (8ë¹„íŠ¸ë¡œ í‘œí˜„) ì™œ???ã…‹...

#define GET(p) (*(unsigned int *)(p))  // ì£¼ì†Œ pì—ì„œ ì›Œë“œë¥¼ ì½ì–´ì˜¤ëŠ” ë§¤í¬ë¡œ
#define PUT(p, val) (*(unsigned int *)(p) = (val))  // pê°€ ê°€ë¦¬í‚¤ëŠ” ìœ„ì¹˜ì— valê°’ì„ ì €ì¥í•˜ëŠ” ë§¤í¬ë¡œ
// *(unsigned int *)(p) : pë¼ëŠ” í¬ì¸í„° ë³€ìˆ˜ë¥¼ unsigned int íƒ€ì…ìœ¼ë¡œ ìºìŠ¤íŒ…. 
// ì´í›„ *ì—°ì‚°ìê°€ í•´ë‹¹ í¬ì¸í„°ê°€ ê°€ë¦¬í‚¤ëŠ ë©”ëª¨ë¦¬ ì£¼ì†Œì— ì ‘ê·¼í•˜ê³  unsigned int íƒ€ì…(4byte)ìœ¼ë¡œ ê°’ì„ ê°€ì ¸ì˜´
// ì¦‰, pê°€ ê°€ë¦¬í‚¤ëŠ” ì£¼ì†Œì— ìˆëŠ” 4ë°”ì´íŠ¸ ì •ìˆ˜ ê°’ì„ ì˜ë¯¸

/* í¬ì¸í„° pì— ì €ì¥ëœ ê°’(í—¤ë”,í‘¸í„°)ì—ì„œ ë¸”ë¡ sizeë¥¼ ì¶”ì¶œ */
#define GET_SIZE(p) (GET(p) & ~0x7)  // 16ì§„ìˆ˜ë¡œ 4ë¹„íŠ¸ ì´ìƒë¶€í„° ì¶”ì¶œ(3ë¹„íŠ¸ ì´í•˜ëŠ” ì˜ë¯¸X). ì¦‰, size ì¶”ì¶œ.
#define GET_ALLOC(p) (GET(p) & 0x1)  // í˜„ì¬ ë¸”ë¡ì˜ ê°€ìš©ì—¬ë¶€ íŒë‹¨

/* ê°ê° (í˜„ì¬)ë¸”ë¡ í¬ì¸í„°ê°€ ì£¼ì–´ì§€ë©´ ë¸”ë¡ì˜ headerì™€ footerë¥¼ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°ë¥¼ ë¦¬í„´ */
#define HDRP(bp) ((char *)(bp) - WSIZE)  // bpì— ì €ì¥ëœ ìƒˆë¡œìš´ ë©”ëª¨ë¦¬ì£¼ì†Œì—ì„œ 1ì›Œë“œ ë’¤ë¥¼ ê°€ë¦¬í‚´.(ì—í•„ë¡œê·¸ í—¤ë” ì•ìœ¼ë¡œ ê°)
#define FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)  // hdrp(bp) í¬ì¸í„° ìœ„ì¹˜ì—ì„œ ì‚¬ì´ì¦ˆë§Œí¼ ìœ„ë¡œ ê°„ ë’¤, 2ì›Œë“œ ë’¤ë¥¼ ê°€ë¦¬í‚´.

/* ë‹¤ìŒê³¼ ì´ì „ ë¸”ë¡ì˜ í¬ì¸í„° ë°˜í™˜ */
#define NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE((char *)(bp)-WSIZE))
#define PREV_BLKP(bp) ((char *)(bp) - GET_SIZE((char *)(bp)-DSIZE))

/********************************************************/
/* ğŸš¨ í•¨ìˆ˜ ì„ ì–¸ ğŸš¨ */

static char *next_bp; // ë‹¤ìŒ í• ë‹¹ ìœ„ì¹˜ë¥¼ ì €ì¥í•˜ëŠ” í¬ì¸í„°
static void *heap_listp; // ì´ˆê¸° ê°€ìƒ ë©”ëª¨ë¦¬ ê³µê°„ì˜ ì‹œì‘ì£¼ì†Œë¥¼ ì €ì¥í•˜ëŠ” ë³€ìˆ˜(í¬ì¸í„°)
static void *extend_heap(size_t words);  // typedef unsigned long size_t (4byte)
static void *coalesce(void *bp);
static void *find_fit(size_t asize);  // ì—¬ê¸°ì„œ firstì™€ next ì½”ë“œê°€ ë‹¬ë¼ì§.
static void place(void *bp, size_t asize);


/********************************************************/

/* ğŸ”¥ ì´ˆê¸°í™” í•¨ìˆ˜ ğŸ”¥
  : í™ ë©”ëª¨ë¦¬ë¥¼ ì´ˆê¸°í™”, ì´ˆê¸° ê°€ìš© ë¸”ë¡ ìƒì„±
  : ì‹¤í–‰ ë„ì¤‘ ë¬¸ì œê°€ ìƒê¸´ë‹¤ë©´ -1, ì •ìƒ ì¢…ë£Œë˜ë©´ 0ì„ ë¦¬í„´  */
int mm_init(void)
{
  // 1) mem_sbrkë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ˆê¸° heap (ê°€ìƒ ë©”ëª¨ë¦¬)ê³µê°„ í• ë‹¹í•˜ê³  ê·¸ê²ƒì´ ì„±ê³µì ìœ¼ë¡œ ì´ë£¨ì–´ì¡ŒëŠ”ì§€ í™•ì¸
  // mem_sbrkëŠ” í™ì„ í™•ì¥í•˜ê³  ê·¸ ì‹œì‘ ì£¼ì†Œë¥¼ ë°˜í™˜. ê·¸ ì£¼ì†Œë¥¼ heap_listpì— ì €ì¥
  // mem_sbrkì˜ ê²°ê³¼ê°’ì´ ìŒìˆ˜ì´ê±°ë‚˜ í™ì„ ë„˜ì–´ê°€ëŠ” í¬ê¸°ë¥¼ í• ë‹¹í•˜ë ¤ê³  í•˜ë©´ (void *)-1 ì„ ë°˜í™˜í•˜ê³ , ì´ëŠ” ë©”ëª¨ë¦¬ í• ë‹¹ ì‹¤íŒ¨ë¥¼ ì˜ë¯¸í•¨.
  if ((heap_listp = mem_sbrk(4*WSIZE)) == (void *)-1)
    // 4*WSIZE = ì´ˆê¸° empty heapì„ ìœ„í•´ í•„ìš”í•œ ì´ ì›Œë“œ ìˆ˜
    return -1;
  
  // 2) ì´ˆê¸° í™ ê³µê°„ì„ ì‚¬ìš©í•˜ê¸° ìœ„í•œ ì´ˆê¸°í™” ì‘ì—… ìˆ˜í–‰
  // PUT ë§¤í¬ë¡œë¥¼ ì‚¬ìš©í•˜ì—¬ í™ ê³µê°„ì˜ ì²« ë¶€ë¶„ì— 4ì›Œë“œì˜ ê³µê°„ì„ ë§Œë“¦
  PUT(heap_listp, 0);  // ì²« ë²ˆì§¸ ì›Œë“œ : ë°”ì´íŠ¸ ì •ë ¬(2ì›Œë“œ ë‹¨ìœ„ë¡œ ë¸”ë¡ ì •ë ¬)ì„ ìœ„í•œ padding
  // ì±…ì—ì„œëŠ” ë”ë¸”ì›Œë“œ(8byte) ì •ë ¬ì¡°ê±´
  // ë§Œì•½ 8byteë¥¼ í™•ë³´í•˜ê³  ì‹¶ë‹¤ë©´, í—¤ë”(4)ì™€ ë°ì´í„°(8)ë¥¼ í•©ì¹œê°’ì€ 12ì´ë¯€ë¡œ 8ì˜ë°°ìˆ˜ì¸ 16ì´ ë  ìˆ˜ ìˆë„ë¡ íŒ¨ë”©(4)í•˜ë‚˜ë¥¼ ì¶”ê°€í•˜ì—¬ ì •ë ¬í•´ì¤Œ.

  // ë‘ë²ˆì§¸ì™€ ì„¸ë²ˆì§¸ ì›Œë“œëŠ” í• ë‹¹ ìš”ì²­ì— ëŒ€í•œ ì²˜ë¦¬ë¥¼ ë‹´ë‹¹í•˜ë©°, í¬ê¸°ëŠ” DSIZEì—¬ì•¼ í•¨.
  PUT(heap_listp + (1 * WSIZE), PACK(DSIZE, 1));  // ë‘ ë²ˆì§¸ ì›Œë“œ : prologue blockì˜ í—¤ë”
  PUT(heap_listp + (2 * WSIZE), PACK(DSIZE, 1));  // ì„¸ ë²ˆì§¸ ì›Œë“œ : prologue blockì˜ í‘¸í„°
  PUT(heap_listp + (3 * WSIZE), PACK(0, 1));  // ë„¤ ë²ˆì§¸ ì›Œë“œ : epilogue blockì˜ í—¤ë”

  heap_listp += (2 * WSIZE);  // í™ ë¦¬ìŠ¤íŠ¸ í¬ì¸í„°ë¥¼ prologue footer ìœ„ì¹˜ë¡œ ì´ë™

  // 3) extend_heap í•¨ìˆ˜ë¥¼ í˜¸ì¶œ : ì´ˆê¸° chunksize ë°”ì´íŠ¸ë¡œ í™•ì¥í•˜ê³  ê°€ìš© ë¸”ë¡ ìƒì„±
  // ì´ ë¸”ë¡ì€ free blockìœ¼ë¡œ ì´ˆê¸°í™” ë¨
  // chunksizeëŠ” byte ë‹¨ìœ„ë¡œ, wsizeë¡œ ë‚˜ëˆ„ë©´ ì›Œë“œ ë‹¨ìœ„ë¡œ ë°”ë€œ!
  if (extend_heap(CHUNKSIZE / WSIZE) == NULL)
    return -1;  // ë§Œì•½ í˜¸ì¶œëœ ê²°ê³¼ê°’ì´ NULLì´ë¼ë©´ -1 ë°˜í™˜

  // next_fit ì‚¬ìš©ì‹œ next_bp ì´ˆê¸°í™”!!
  next_bp = heap_listp;

  return 0;  // ì´ˆê¸°í™” ì‘ì—… ì™„ë£Œì‹œ 0 ë°˜í™˜
}

/********************************************************/
/* ğŸ”¥ heap ë©”ëª¨ë¦¬ í™•ì¥ í•¨ìˆ˜ ğŸ”¥
  : mem_sbrk í•¨ìˆ˜ë¥¼ ì´ìš©í•˜ì—¬ ìš”ì²­í•œ í¬ê¸°ë§Œí¼ í™ ë©”ëª¨ë¦¬ë¥¼ í• ë‹¹ í›„, 
  : í—¤ë”ì™€ í‘¸í„°ë¥¼ ì„¤ì •í•´ì£¼ê³ , ë¸”ë¡ì„ í•©ì¹  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•˜ì—¬ í•©ì¹˜ëŠ” ì‘ì—…ì„ ìˆ˜í–‰  */
static void *extend_heap(size_t words)
{
  // charíƒ€ì… í¬ì¸í„° bpì™€ size_tíƒ€ì… size ë³€ìˆ˜ ì„ ì–¸
  char *bp;  // ìƒˆë¡œ í™•ì¥ëœ ë¸”ë¡ì˜ ì£¼ì†Œ ì €ì¥
  size_t size;  // í™•ì¥í•  í¬ê¸° ì €ì¥

  size = (words % 2) ? (words + 1) * WSIZE : words * WSIZE;
  // wordsê°€ 2ì˜ ë°°ìˆ˜ê°€ ì•„ë‹ˆë¼ë©´, wordsì— 1ì„ ë”í•´ì„œ 2ì˜ ë°°ìˆ˜ë¡œ ë§Œë“¤ì–´ ì¤Œ(ë”ë¸”ì›Œë“œ ì •ë ¬)
  // WSIZE(4byte)ë¥¼ ê³±í•´ì£¼ëŠ”ê±´ ê·¸ëƒ¥ ì›Œë“œ ë‹¨ìœ„ë¥¼ ë‹¤ì‹œ ë°”ì´íŠ¸ ë‹¨ìœ„ë¡œ ë°”ê¿”ì£¼ëŠ” ê²ƒ!
  // ? ì—°ì‚°ì --> rule ? a : b ì¼ ë•Œ, ruleì´ ì°¸ì´ë©´ aë¥¼, ê±°ì§“ì´ë©´ bë¥¼ ë°˜í™˜

  if ((long)(bp = mem_sbrk(size)) == -1)  // mem_sbrk í•¨ìˆ˜ë¥¼ í˜¸ì¶œ, í™ì„ í™•ì¥
    return NULL;  // ì‹¤íŒ¨ ì‹œ NULL ë°˜í™˜
  // ì„±ê³µì‹œ, bpì—ëŠ” ìƒˆë¡œ í• ë‹¹ëœ ë©”ëª¨ë¦¬ë¸”ë¡ì˜ ì‹œì‘ ì£¼ì†Œê°€ ì €ì¥ë˜ê³ , long íƒ€ì…ìœ¼ë¡œ ìºìŠ¤íŒ…í•˜ì—¬ ë°˜í™˜
  // sbrkí•¨ìˆ˜ëŠ” void* íƒ€ì…ì˜ ì£¼ì†Œë¥¼ ë°˜í™˜í•˜ê¸° ë•Œë¬¸ì— bpì— ê·¸ëŒ€ë¡œ ì €ì¥í•˜ë©´ íƒ€ì…ì´ ë§ì§€ ì•Šì•„ì„œ ì˜¤ë¥˜ ë°œìƒ.  

  // ìƒˆë¡œ í• ë‹¹ëœ ë¸”ë¡ì˜ í—¤ë”ì™€ í‘¸í„°ë¥¼ ì´ˆê¸°í™”.
  PUT(HDRP(bp), PACK(size, 0));  // free ë¸”ë¡ headerì— ë‚´ìš© ì €ì¥
  PUT(FTRP(bp), PACK(size, 0));  // free ë¸”ë¡ footerì— ë‚´ìš© ì €ì¥
  PUT(HDRP(NEXT_BLKP(bp)), PACK(0, 1));  // ìƒˆë¡œìš´ epilogue header

  // ì´ì „ í™ì´ ê°€ìš©ë¸”ë¡ìœ¼ë¡œ ëë‚¬ë‹¤ë©´, coalesce í•¨ìˆ˜ë¡œ ë‘ ê°œì˜ ê°€ìš©ë¸”ë¡ì„ í†µí•©
  return coalesce(bp);
}

/********************************************************/
/* ğŸ”¥ ê°€ìš© ë¸”ë¡ ë³‘í•© í•¨ìˆ˜ ğŸ”¥ */
static void *coalesce(void *bp)
{
  size_t prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp))); // ì´ì „ ë¸”ë¡ì˜ í‘¸í„°ì—ì„œ í• ë‹¹ ì—¬ë¶€ ê°€ì ¸ì˜´
  size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp))); // ë‹¤ìŒ ë¸”ëŸ­ì˜ í—¤ë”ì—ì„œ í• ë‹¹ ì—¬ë¶€ ê°€ì ¸ì˜´
  size_t size = GET_SIZE(HDRP(bp)); // í˜„ì¬ ë¸”ë¡ì˜ í—¤ë”ì—ì„œ ì‚¬ì´ì¦ˆ ì •ë³´ë¥¼ ê°€ì ¸ì˜´

  // CASE 1) ì „í›„ ë¸”ë¡ì´ ëª¨ë‘ í• ë‹¹
  if (prev_alloc && next_alloc) {
    return bp;
  }
  // CASE 2) ì „ ë¸”ë¡ì€ í• ë‹¹, í›„ ë¸”ë¡ ê°€ìš© ìƒíƒœ : í›„ ë¸”ë¡ê³¼ ë³‘í•©
  else if(prev_alloc && !next_alloc) {
    size += GET_SIZE(HDRP(NEXT_BLKP(bp))); // ë‹¤ìŒ ë¸”ë¡ì˜ í—¤ë”ì—ì„œ ì‚¬ì´ì¦ˆ ê°€ì ¸ì™€ì„œ í˜„ì¬ ë¸”ë¡ ì‚¬ì´ì¦ˆì— ë”í•¨

    PUT(HDRP(bp), PACK(size, 0));  // í˜„ì¬ ë¸”ë¡ì˜ í—¤ë”ì— ì‚¬ì´ì¦ˆ/ê°€ìš©ì—¬ë¶€ ì •ë³´ ì €ì¥.
    PUT(FTRP(bp), PACK(size, 0));  // ìœ„ì— ì €ì¥ëœ ì •ë³´ë¡œ í•©ì³ì§„ ë¸”ë¡ì˜ í‘¸í„°ë¥¼ ì°¾ì•„ê°€ì„œ ì •ë³´ ì €ì¥
  }
  // CASE 3) ì „ ë¸”ë¡ì´ ê°€ìš©, í›„ ë¸”ë¡ í• ë‹¹ : ì „ ë¸”ë¡ê³¼ ë³‘í•©
  else if(!prev_alloc && next_alloc) {
    size += GET_SIZE(HDRP(PREV_BLKP(bp)));  // ì´ì „ ë¸”ë¡ì˜ í‘¸í„°ì—ì„œ ì‚¬ì´ì¦ˆë¥¼ ê°€ì ¸ì™€ì„œ í˜„ì¬ë¸”ë¡ ì‚¬ì´ì¦ˆì— ë”í•¨

    PUT(FTRP(bp), PACK(size, 0));  // í˜„ì¬ë¸”ë¡ì˜ í‘¸í„°ì— ì‚¬ì´ì¦ˆ/ê°€ìš© ì •ë³´ ì €ì¥
    PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));  // ì´ì „ ë¸”ë¡ì˜ í—¤ë”ì— ì‚¬ì´ì¦ˆ/ê°€ìš© ì •ë³´ ì €ì¥

    bp = PREV_BLKP(bp);  //  ë³‘í•© í›„, ë‹¤ì‹œ ì´ì „ ë¸”ë¡ì˜ í¬ì¸í„° ë°˜í™˜
  }
  // CASE 4) ì „í›„ ë¸”ë¡ ëª¨ë‘ ê°€ìš©
  else {
    size += GET_SIZE(HDRP(PREV_BLKP(bp))) + GET_SIZE(FTRP(NEXT_BLKP(bp)));  // ì´ì „ë¸”ë¡ì˜ í‘¸í„° + ë‹¤ìŒë¸”ë¡ì˜ í—¤ë” + í˜„ì¬ë¸”ëŸ­ ì‚¬ì´ì¦ˆ

    PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));
    PUT(FTRP(NEXT_BLKP(bp)), PACK(size, 0));

    bp = PREV_BLKP(bp);
  }
  
  // ì¶”ê°€) next fit
  // next fit ë°©ì‹ì—ì„œëŠ” ì´ì „ì— ê°€ìš©ë¸”ë¡ì„ ì°¾ì•˜ë˜ ìœ„ì¹˜ë¶€í„° ì´ì–´ì„œ íƒìƒ‰ì„ ì§„í–‰í•˜ê¸° ë•Œë¬¸ì—, íƒìƒ‰ì„ ì´ì–´ë‚˜ê°ˆ ìœ„ì¹˜ë¥¼ ê¸°ì–µí•´ì•¼ í•¨.(next_bpì— ì €ì¥)
  // ê·¸ëŸ°ë°, coalesce í•¨ìˆ˜ì—ì„œëŠ” ì¸ì ‘í•œ ê°€ìš©ë¸”ë¡ì„ í•˜ë‚˜ë¡œ í•©ì³ì£¼ëŠ” ì‘ì—…ì„ ìˆ˜í–‰í•˜ê¸° ë•Œë¬¸ì—,
  // next_bpê°€ í•©ì³ì§€ëŠ” ë¸”ë¡ ì‚¬ì´ì— ìë¦¬í•˜ê³  ìˆë‹¤ë©´, next_bpì˜ ìœ„ì¹˜ëŠ” ìƒˆë¡­ê²Œ í•©ì³ì§„ ë¸”ë¡ì˜ ì‹œì‘ ìœ„ì¹˜ë¡œ ì˜®ê²¨ì¤˜ì•¼ í•¨.
  // ì´ë¡œì¨ next fit ë°©ì‹ì˜ íƒìƒ‰ì„ ìœ ì§€í•  ìˆ˜ ìˆë„ë¡ í•´ ì¤Œ.
  if ((next_bp > (char *)(bp)) && (next_bp < NEXT_BLKP(bp))) // next_bpê°€ ì¤‘ê°„ì— ë‚€ ê²½ìš°ì—
    next_bp = bp;  // ì‹œì‘ìœ„ì¹˜ë¡œ ì˜®ê²¨ì¤Œ

  return bp;  // í¬ì¸í„° ë°˜í™˜
}

/********************************************************/
/* ğŸ”¥ ë©”ëª¨ë¦¬ í• ë‹¹ í•¨ìˆ˜ ğŸ”¥ */
void *mm_malloc(size_t size)
{
  size_t asize;  // í• ë‹¹í•  ë¸”ë¡ì˜ ì´ í¬ê¸° ì €ì¥
  size_t extendsize;  // í™ì„ í™•ì¥í•  í¬ê¸° ì €ì¥
  char *bp;  // í• ë‹¹ëœ ë¸”ë¡ì˜ ì£¼ì†Œ ì €ì¥

  // 1) ìš”ì²­í•œ ë©”ëª¨ë¦¬ê°€ 0ì´ê±°ë‚˜ ìŒìˆ˜ì´ë©´ nullê°’ ë°˜í™˜
  if (size == 0)
    return NULL;

  // 2) ìš”ì²­í•œ ë©”ëª¨ë¦¬ê°€ DSIZE(8byte)ë³´ë‹¤ ê°™ê±°ë‚˜ ì‘ìœ¼ë©´, ë¸”ë¡ì˜ ìµœì†Œ í¬ê¸°ì¸ 2*DSIZE(16byte)ë¡œ ì„¤ì •
  // 8ë°”ì´íŠ¸ëŠ” ì •ë ¬ ê¸°ì¤€ì„ ë§Œì¡±í•˜ê¸° ìœ„í•´, ë‚˜ë¨¸ì§€ëŠ” í—¤ë”(4byte)ì™€ í‘¸í„°(4byte)ë¥¼ ê³ ë ¤í•´ì•¼ í•˜ê¸° ë•Œë¬¸.
  if (size <= DSIZE)
    asize = 2 * DSIZE;
  // 3) ìš”ì²­í•œ ë©”ëª¨ë¦¬ê°€ DSIZEë³´ë‹¤ í° ê²½ìš°, DSIZEì˜ ë°°ìˆ˜ë¡œ ì˜¬ë¦¼í•˜ì—¬ ê³„ì‚°
  else
    asize = DSIZE * ((size + DSIZE + (DSIZE-1)) / DSIZE);
    // ìˆ˜ì‹ ì„¤ëª… : ë©”ëª¨ë¦¬ ì •ë ¬ ì¡°ê±´ì„ ë§Œì¡±í•˜ë©´ì„œ, ìš”ì²­í•œ í¬ê¸°ì— ìµœëŒ€í•œ ê°€ê¹Œìš´ ë¸”ë¡ í¬ê¸° ì œê³µ
    // ìš”ì²­í•œ ë©”ëª¨ë¦¬(size)ì— DSIZE(8byte, í—¤ë”/í‘¸í„°)ë¥¼ ë¨¼ì € ë”í•˜ë©´ ìµœì†Œ ë¸”ë¡ í¬ê¸°ê°€ ë¨.
    // Dsizeë¡œ ë‚˜ëˆ´ì„ ë•Œ, ë²„ë¦¼ ì—°ì‚°ì„ ìˆ˜í–‰í•˜ê¸° ë•Œë¬¸ì— ë‚˜ë¨¸ì§€ê°€ ë‚˜ì˜¬ ìˆ˜ ìˆëŠ” ë²”ìœ„ë‚´(7)ì—ì„œ ë”í•´ì¤Œ

  // 4) find_fit í•¨ìˆ˜(í• ë‹¹ê¸°)ë¡œ ì ì ˆí•œ ê°€ìš© ë¸”ë¡ íƒìƒ‰ ë° ë°°ì¹˜
  if ((bp = find_fit(asize)) != NULL)  // íƒìƒ‰ ì„±ê³µ ì‹œ
  {
    place(bp, asize);  // place í•¨ìˆ˜ë¡œ ë¸”ë¡ ë°°ì¹˜
    return bp;  // í•´ë‹¹ ë¸”ë¡ ì£¼ì†Œ ë°˜í™˜
  }
  // 5) ì ì ˆí•œ ê°€ìš© ë¸”ë¡ì´ ì—†ì„ ê²½ìš°, í™ í™•ì¥(ìƒˆ ê°€ìš©ë¸”ë¡ í™•ë³´) ë° ë°°ì¹˜
  // í™•ì¥í•  í™ì˜ í¬ê¸° ê²°ì •. ìš”ì²­í•œ í¬ê¸°ì™€ chunksize ì¤‘ í° ê°’ì„ ì„ íƒí•¨
  extendsize = MAX(asize, CHUNKSIZE);  
  if ((bp = extend_heap(extendsize / WSIZE)) == NULL)
    return NULL;
  place(bp, asize); 
  return bp;
}

/********************************************************/
/* ğŸŒ¸ ê°€ìš© ë¸”ë¡ ê²€ìƒ‰ í•¨ìˆ˜(1) : First_fit (54ì ) ğŸŒ¸ */
// static void *find_fit(size_t asize)  // ë§¤ê°œë³€ìˆ˜ë¡œ í• ë‹¹í•  ë¸”ë¡ì˜ í¬ê¸°ë¥¼ ë°›ìŒ
// {
//   void *bp;  // bp í¬ì¸í„° ì„ ì–¸. í• ë‹¹ ê°€ëŠ¥í•œ ë¸”ë¡ì„ ê°€ë¦¬í‚´

//   // 1) heap_listpë¶€í„° ëª¨ë“  ë¸”ë¡ì„ ë°˜ë³µí•˜ì—¬ í• ë‹¹ ê°€ëŠ¥í•œ ë¸”ë¡ì„ íƒìƒ‰
//   // ì¡°ê±´ 1: bpëŠ” heap_listpë¥¼ ê°€ë¦¬í‚´. heap_listpëŠ” ê°€ìƒë©”ëª¨ë¦¬ ì²« ë²ˆì§¸ ë¸”ë¡ì„ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°.
//   // ì¡°ê±´ 2: í¬ì¸í„°ê°€ ê°€ë¦¬í‚¤ëŠ” ë¸”ë¡ì˜ í—¤ë” ì‚¬ì´ì¦ˆê°€ 0ë³´ë‹¤ í° ê²½ìš°, ì¦‰ ëª¨ë“  ë¸”ë¡ì„ íƒìƒ‰í•˜ê² ë‹¤ëŠ” ì¡°ê±´.(í™ì˜ ë§ˆì§€ë§‰ ë¸”ë¡ì€ 0ì„ ê°€ë¦¬í‚¤ë¯€ë¡œ)
//   // ì¡°ê±´ 3: ë‹¤ìŒ ë¸”ë¡ì˜ ì£¼ì†Œë¥¼ bpì— ì €ì¥í•˜ì—¬ ë£¨í”„ ë°˜ë³µ
//   for (bp = heap_listp; GET_SIZE(HDRP(bp)) > 0; bp = NEXT_BLKP(bp)) {
//     // 2) ë¸”ë¡ì´ ì•„ì§ í• ë‹¹ë˜ì§€ ì•Šì•˜ê³ , ìš”ì²­í•œ í¬ê¸°(asize)ë³´ë‹¤ í¬ê±°ë‚˜ ê°™ì€ ê³µê°„ì´ ìˆëŠ”ì§€ í™•ì¸
//     if (!GET_ALLOC(HDRP(bp)) && (asize <= GET_SIZE(HDRP(bp)))) {
//       return bp;  // íƒìƒ‰ ì„±ê³µ ì‹œ í•´ë‹¹ bp ë°˜í™˜
//     }
//   }
//   return NULL;  // í• ë‹¹ ê°€ëŠ¥í•œ ë¸”ë¡ì„ ì°¾ì§€ ëª»í•  ê²½ìš° NULLê°’ ë°˜í™˜
// }

/* ğŸŒ¸ ê°€ìš© ë¸”ë¡ ê²€ìƒ‰ í•¨ìˆ˜(2) : Next_fit (84ì ) ğŸŒ¸ 
  next_fit ë°©ì‹ìœ¼ë¡œ ë©”ëª¨ë¦¬ í• ë‹¹ ê°€ëŠ¥í•œ ê³µê°„ì„ ì°¾ì•„ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ */
static void *find_fit(size_t asize) {
  
  char *bp = next_bp; // í˜„ì¬ í• ë‹¹ ìœ„ì¹˜ë¥¼ ì €ì¥í•˜ëŠ” í¬ì¸í„° next_bpë¥¼ bpì— ì €ì¥

  /* ë‹¤ìŒ í• ë‹¹ ìœ„ì¹˜ë¶€í„° ë¸”ë¡ì˜ ëê¹Œì§€ ìˆœíšŒí•˜ë©°, asizeë³´ë‹¤ í° ê³µê°„ì„ ì°¾ìŒ */
  for (; GET_SIZE(HDRP(next_bp)) > 0; next_bp = NEXT_BLKP(next_bp)) {
    if (!GET_ALLOC(HDRP(next_bp)) && (asize <= GET_SIZE(HDRP(next_bp)))) {
      /* asizeë³´ë‹¤ í° ê³µê°„ì„ ì°¾ì•˜ì„ ê²½ìš°, í•´ë‹¹ ë¸”ë¡ì„ í• ë‹¹ ê°€ëŠ¥í•œ ë¸”ë¡ìœ¼ë¡œ ì €ì¥í•˜ê³ ,
        * ë‹¤ìŒ í• ë‹¹ ìœ„ì¹˜ë¥¼ í•´ë‹¹ ë¸”ë¡ì˜ ë‹¤ìŒ ë¸”ë¡ìœ¼ë¡œ ê°±ì‹  í›„ ë°˜í™˜ */
      return next_bp;
    }
  }

  /* í• ë‹¹ ê°€ëŠ¥í•œ ê³µê°„ì„ ì°¾ì§€ ëª»í•œ ê²½ìš°, ì²˜ìŒë¶€í„° ë‹¤ì‹œ ìˆœíšŒ */
  for (next_bp = heap_listp; next_bp < bp; next_bp = NEXT_BLKP(next_bp)) {
    if (!GET_ALLOC(HDRP(next_bp)) && (asize <= GET_SIZE(HDRP(next_bp)))) {
      return next_bp;
    }
  }

  return NULL;
}

/********************************************************/
/* ğŸ”¥ ë¸”ë¡ í• ë‹¹ í•¨ìˆ˜ ğŸ”¥ 
  ë§¤ê°œë³€ìˆ˜ë¡œ í• ë‹¹ë˜ëŠ” ë¸”ë¡ì˜ í¬ì¸í„°(bp)ì™€ í• ë‹¹í•  ë¸”ë¡ì˜ í¬ê¸°(asize)ë¥¼ ë°›ìŒ  */
static void place(void * bp, size_t asize) 
{
  // 1) bpê°€ ê°€ë¦¬í‚¤ëŠ” ê°€ìš©ë¸”ë¡ì˜ í—¤ë”ì—ì„œ ì‚¬ì´ì¦ˆ ì •ë³´ë¥¼ ê°€ì ¸ì™€ ë³€ìˆ˜ì— ì €ì¥
  size_t csize = GET_SIZE(HDRP(bp));  

  // 2) ë§Œì•½ ë¸”ë¡ì„ í• ë‹¹í•˜ê³  ë‚¨ì€ ê³µê°„ì´ 8byteë³´ë‹¤ í¬ë‹¤ë©´, ë¸”ë¡ì„ ë¶„í• í•¨
  if ((csize - asize) >= (2*DSIZE)) {
    PUT(HDRP(bp), PACK(asize, 1));  // ê°€ìš©ë¸”ë¡ì˜ í—¤ë”ì— ì •ë³´ ì €ì¥
    PUT(FTRP(bp), PACK(asize, 1));  // í‘¸í„° ì •ë³´ ì €ì¥
    bp = NEXT_BLKP(bp);  // í¬ì¸í„°ë¥¼ ë‹¤ìŒ ë¸”ë¡(ë¶„í• í•œ ë‚¨ì€ ë¸”ë¡)ìœ¼ë¡œ ì˜®ê¹€
    PUT(HDRP(bp), PACK(csize - asize, 0));  // ê°€ìš©ë¸”ë¡ì˜ í—¤ë”ì— ì •ë³´ ì €ì¥
    PUT(FTRP(bp), PACK(csize - asize, 0));  // ê°€ìš©ë¸”ë¡ì˜ í‘¸í„°ì— ì •ë³´ ì €ì¥
  } 
  else {  // 3) ë¸”ë¡ì„ í• ë‹¹í•˜ê³  ë‚¨ì€ ê³µê°„ì´ 8byteë³´ë‹¤ ì‘ë‹¤ë©´, í•´ë‹¹ ê°€ìš©ê³µê°„ì„ ëª¨ë‘ ì‚¬ìš©í•¨
    PUT(HDRP(bp), PACK(csize, 1));
    PUT(FTRP(bp), PACK(csize, 1));
  }
}

/********************************************************/
/* ğŸ”¥ ë©”ëª¨ë¦¬ í•´ì œ í•¨ìˆ˜ ğŸ”¥ 
  ì£¼ì–´ì§„ bpë¡œ í—¤ë”ì™€ í‘¸í„°ì˜ í• ë‹¹ ì •ë³´ë¥¼ free(0)ìœ¼ë¡œ ë°”ê¿”ì£¼ë©°, ë°˜í™˜í•˜ëŠ” ê°’ì€ ì—†ìŒ.
  ì¸ìë¡œ ë°›ì€ í¬ì¸í„°ê°€ ì´ì „ì— malloc, reallocìœ¼ë¡œ í• ë‹¹ëœ ë©”ëª¨ë¦¬ì´ê³ , ê·¸ê²ƒì´ freeë˜ì§€ ì•Šì•˜ì„ ë•Œì—ë§Œ ì‹¤í–‰ë˜ì–´ì•¼ í•¨. */
void mm_free(void *bp)
{
  size_t size = GET_SIZE(HDRP(bp));  // í•´ë‹¹ í¬ì¸í„°ê°€ ê°€ë¦¬í‚¤ëŠ” ë¸”ë¡ì˜ í—¤ë”ì—ì„œ ì‚¬ì´ì¦ˆ ì •ë³´ë¥¼ ê°€ì ¸ì˜´

  PUT(HDRP(bp), PACK(size, 0));  // í—¤ë”ì˜ ê°€ìš©ì •ë³´ë¥¼ 0ìœ¼ë¡œ ë³€í™˜
  PUT(FTRP(bp), PACK(size, 0));  // í‘¸í„°ì˜ ê°€ìš©ì •ë³´ë¥¼ 0ìœ¼ë¡œ ë³€í™˜
  coalesce(bp);  // coalesce í•¨ìˆ˜ í˜¸ì¶œ, ì „í›„ ê°€ìš©ë©”ëª¨ë¦¬ì™€ ë³‘í•©
}

/********************************************************/
/* ğŸ”¥ ë©”ëª¨ë¦¬ í¬ê¸° ì¡°ì • í•¨ìˆ˜ ğŸ”¥ 
  ì´ë¯¸ í• ë‹¹ëœ ë©”ëª¨ë¦¬ì˜ í¬ê¸°ë¥¼ ì¡°ì •í•˜ê³  ì‹¶ì„ ë•Œ ì‚¬ìš©í•˜ëŠ” í•¨ìˆ˜. 
  ë§¤ê°œë³€ìˆ˜ë¡œ ë°”ê¾¸ê³  ì‹¶ì€ ë¸”ë¡ì„ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°(bp)ì™€ ìƒˆë¡œ ë°”ê¾¸ê³  ì‹¶ì€ í¬ê¸°(size)ë¥¼ ë°›ìŒ */
void *mm_realloc(void *bp, size_t size)
{
  void *new_bp;  // ìƒˆë¡œìš´ ë¸”ë¡ì„ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„° ì„ ì–¸
  size_t copySize;  // ì´ì „ ë¸”ë¡ì˜ í¬ê¸° ì •ë³´ë¥¼ ì €ì¥í•  ë³€ìˆ˜ ì„ ì–¸
  
  // 1) mallocìœ¼ë¡œ í¬ê¸°ê°€ sizeì¸ ìƒˆë¡œìš´ ë¸”ë¡ì„ í• ë‹¹í•˜ê³  ê·¸ ì£¼ì†Œë¥¼ new_bpì— ì €ì¥
  new_bp = mm_malloc(size);
  if (new_bp == NULL)  // ë§Œì•½ mallocì´ ìƒˆë¡œìš´ ë¸”ë¡ì„ í• ë‹¹í•˜ì§€ ëª»í–ˆë‹¤ë©´ nullê°’ ë°˜í™˜
    return NULL;

  // 2) ì´ì „ ë¸”ë¡ì˜ í—¤ë”ì—ì„œ ì‚¬ì´ì¦ˆ ì •ë³´ ê°€ì ¸ì˜´
  copySize = GET_SIZE(HDRP(bp));

  // 3) ë§Œì•½ ìƒˆë¡œ ìš”ì²­í•œ í¬ê¸°(size)ê°€ ì´ì „ ë¸”ë¡ì˜ sizeë³´ë‹¤ ì‘ë‹¤ë©´ copysize ë³€ìˆ˜ì— size ì €ì¥
  if (size < copySize)
    copySize = size;
  // 4) memcpy í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ ì´ì „ ë¸”ë¡ì—ì„œ copysizeë§Œí¼ì˜ ë°ì´í„°ë¥¼ ìƒˆë¡œ í• ë‹¹í•œ ë¸”ë¡ìœ¼ë¡œ ë³µì‚¬
  memcpy(new_bp, bp, copySize);
  /* memcpy : Cí‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ í•¨ìˆ˜ ì¤‘ í•˜ë‚˜. ë©”ëª¨ë¦¬ ë¸”ë¡ì„ ë³µì‚¬í•˜ëŠ” í•¨ìˆ˜
    : ë§¤ê°œë³€ìˆ˜ë¡œ ë³µì‚¬ ëŒ€ìƒ ë©”ëª¨ë¦¬ì˜ ì‹œì‘ì£¼ì†Œ, ë³µì‚¬í•  ë°ì´í„° ë¸”ë¡ì˜ ì‹œì‘ì£¼ì†Œ, ë³µì‚¬í•  ë°ì´í„°ì˜ í¬ê¸°(byte)ë¥¼ ë°›ìŒ 
    : ì—¬ê¸°ì„œëŠ” bpê°€ ê°€ë¦¬í‚¤ëŠ” ë©”ëª¨ë¦¬ ë¸”ë¡ì˜ ë°ì´í„°ë¥¼ new_bpê°€ ê°€ë¦¬í‚¤ëŠ” ë©”ëª¨ë¦¬ ë¸”ë¡ìœ¼ë¡œ ë³µì‚¬í•¨. */
  
  mm_free(bp);  // ì´ì „ ë¸”ë¡ í•´ì œ
  return new_bp;  // ìƒˆë¡œìš´ í¬ì¸í„° ë°˜í™˜
}

// ì¢€ ë” ê²½ìš°ì˜ ìˆ˜ë¥¼ ë‚˜ëˆ ì„œ ì§œë´ë„ ë  ê²ƒ ê°™ë‹¤.